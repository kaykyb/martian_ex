defmodule MartianEx.Parser do
  @moduledoc """
  `Parser` converts Markdown AST generated by Earmark into Notion block objects
  """

  alias MartianEx.Notion.Blocks
  alias MartianEx.Notion.Common

  @doc """
  Converts Earmark AST elements into Notion block objects

  ## Examples

    iex> MartianEx.Parser.parse_blocks([{"h1", [], ["Hello!"], %{}}])
    [
      %{
        type: "heading_1",
        object: "block",
        heading_1: %{
          rich_text: [
            %{
              type: "text",
              text: %{content: "Hello!"},
              annotations: %{
                code: false,
                color: "default",
                italic: false,
                underline: false,
                strikethrough: false,
                bold: false
              }
            }
          ]
        }
      }
    ]

  """
  @spec parse_blocks(any()) :: list()
  def parse_blocks(root) do
    Enum.flat_map(root, &parse_node/1)
  end

  defp parse_node({"h1", _attributes, children, _}) do
    rich_text = Enum.flat_map(children, &parse_inline/1)
    [Blocks.heading_one(rich_text)]
  end

  defp parse_node({"h2", _attributes, children, _}) do
    rich_text = Enum.flat_map(children, &parse_inline/1)
    [Blocks.heading_two(rich_text)]
  end

  defp parse_node({heading, _attributes, children, _})
       when heading in ["h3", "h4", "h5", "h6"] do
    rich_text = Enum.flat_map(children, &parse_inline/1)
    [Blocks.heading_three(rich_text)]
  end

  defp parse_node({"p", _attributes, children, _}) do
    grouped_children =
      Enum.group_by(children, fn
        {"img", _, _, _} -> :images
        _ -> :texts
      end)

    images = Map.get(grouped_children, :images, [])
    texts = Map.get(grouped_children, :texts, [])

    image_blocks = Enum.flat_map(images, &parse_node/1)
    text_blocks = Enum.flat_map(texts, &parse_inline/1)

    case text_blocks do
      [] -> image_blocks
      _ -> [Blocks.paragraph(text_blocks)] ++ image_blocks
    end
  end

  defp parse_node({"img", attributes, _children, _}) do
    url = attributes |> Map.new() |> Map.get("src")
    [Blocks.image(url)]
  end

  defp parse_node({"pre", _attributes, children, _}) do
    Enum.flat_map(children, &parse_node/1)
  end

  defp parse_node({"code", attributes, children, _}) do
    language = attributes |> Map.new() |> Map.get("class", "plain text")
    rich_text = Enum.map(children, &Common.rich_text/1)
    [Blocks.code(rich_text, language)]
  end

  defp parse_node({"blockquote", _attributes, children, _}) do
    children = Enum.flat_map(children, &parse_node/1)
    [Blocks.blockquote([], children)]
  end

  # Unordered lists
  defp parse_node({"ul", _attributes, children, _}) do
    Enum.flat_map(children, fn
      {"li", _, _, _} = node ->
        parse_ul_node(node)

      _ ->
        []
    end)
  end

  # TODO: Handle the start attribute?
  defp parse_node({"ol", _attributes, children, _}) do
    Enum.flat_map(children, fn
      {"li", _attributes, children, _} ->
        rich_text = Enum.flat_map(children, &parse_inline/1)
        parsed_children = Enum.flat_map(children, &parse_node/1)

        [Blocks.numbered_list_item(rich_text, parsed_children)]

      _ ->
        []
    end)
  end

  defp parse_node({"table", _attributes, children, _}) do
    table_width =
      case children do
        [{_, _, [{_, _, children, _} | _], _} | _] -> length(children)
        _ -> 0
      end

    rows = Enum.flat_map(children, &parse_node/1)
    [Blocks.table(rows, table_width)]
  end

  defp parse_node({"thead", _, children, _}) do
    Enum.flat_map(children, &parse_node/1)
  end

  defp parse_node({"tbody", _, children, _}) do
    Enum.flat_map(children, &parse_node/1)
  end

  defp parse_node({"tr", _, children, _}) do
    cells = Enum.flat_map(children, &parse_node/1)
    [Blocks.table_row(cells)]
  end

  defp parse_node({"td", _, children, _}) do
    [Enum.flat_map(children, &parse_inline/1)]
  end

  defp parse_node({"th", _, children, _}) do
    [Enum.flat_map(children, &parse_inline/1)]
  end

  defp parse_node(_), do: []

  defp parse_inline(text, annotations \\ [], opts \\ [])

  defp parse_inline(text, annotations, opts) when is_bitstring(text) do
    [Common.rich_text(text, annotations, opts)]
  end

  defp parse_inline({"del", _attributes, children, _}, annotations, opts) do
    annotations = Keyword.put(annotations, :strikethrough, true)
    Enum.flat_map(children, &parse_inline(&1, annotations, opts))
  end

  defp parse_inline({"em", _attributes, children, _}, annotations, opts) do
    annotations = Keyword.put(annotations, :italic, true)
    Enum.flat_map(children, &parse_inline(&1, annotations, opts))
  end

  defp parse_inline({"strong", _attributes, children, _}, annotations, opts) do
    annotations = Keyword.put(annotations, :bold, true)
    Enum.flat_map(children, &parse_inline(&1, annotations, opts))
  end

  defp parse_inline({"a", attributes, children, _}, annotations, opts) do
    url = attributes |> Map.new() |> Map.get("href")
    opts = Keyword.put(opts, :url, url)
    Enum.flat_map(children, &parse_inline(&1, annotations, opts))
  end

  defp parse_inline({"code", _attributes, children, _}, annotations, opts) do
    annotations = Keyword.put(annotations, :code, true)
    [Common.rich_text(children, annotations, opts)]
  end

  defp parse_inline(_, _, _), do: []

  # Add inline equation support using earmark plugin
  # defp parse_inline({"code", _attributes, children, _}, annotations, opts) do
  #   annotations = Keyword.put(annotations, :code, true)
  #   [Common.rich_text(children, annotations, opts)]
  # end

  ## Unchecked todo
  defp parse_ul_node({"li", _attributes, ["[ ] " <> title | rest_children], _}) do
    children = [title | rest_children]

    rich_text = Enum.flat_map(children, &parse_inline/1)
    parsed_children = Enum.flat_map(children, &parse_node/1)

    [Blocks.to_do(false, rich_text, parsed_children)]
  end

  defp parse_ul_node({"li", _attributes, [{a, b, ["[ ] " <> title | rest_children], c} | d], _}) do
    children = [{a, b, [title | rest_children], c} | d]

    rich_text = Enum.flat_map(children, &parse_inline/1)
    parsed_children = Enum.flat_map(children, &parse_node/1)

    [Blocks.to_do(false, rich_text, parsed_children)]
  end

  ## Checked todo
  defp parse_ul_node({"li", _attributes, ["[x] " <> title | rest_children], _}) do
    children = [title | rest_children]

    rich_text = Enum.flat_map(children, &parse_inline/1)
    parsed_children = Enum.flat_map(children, &parse_node/1)

    [Blocks.to_do(true, rich_text, parsed_children)]
  end

  defp parse_ul_node({"li", _attributes, [{a, b, ["[x] " <> title | rest_children], c} | d], _}) do
    children = [{a, b, [title | rest_children], c} | d]

    rich_text = Enum.flat_map(children, &parse_inline/1)
    parsed_children = Enum.flat_map(children, &parse_node/1)

    [Blocks.to_do(true, rich_text, parsed_children)]
  end

  ## Bulleted list item
  defp parse_ul_node({"li", _attributes, children, _}) do
    rich_text = Enum.flat_map(children, &parse_inline/1)
    parsed_children = Enum.flat_map(children, &parse_node/1)

    [Blocks.bulleted_list_item(rich_text, parsed_children)]
  end
end
